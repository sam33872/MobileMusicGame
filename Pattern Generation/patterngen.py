# -*- coding: utf-8 -*-
"""patternGen.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1x8HAOpqLwQ9jrD-jmxhIL161UV9ICnOM
"""

## Run each section in the order given
## All section must be run, including sections that have been hidden
## Connect to your google drive
from google.colab import drive
drive.mount('/content/drive')

#@title
import librosa
import librosa.display

## To use this pattern generator, run each section of code by pressing the play button.
## The above two sections must be run before this section
## Next fill in the missing data below
## Add a song into your drive and add the link below. The song name should be in the format song name followed by artist name and be an mp3
## Add a song name and artist name
## Select a difficulty between 1 and 3

## Example
## songLocation = '/content/drive/My Drive/songNameartistName.mp3'
## songName = "SongName"
## artistName = "ArtistName"
## dif = 3

## Song file location, from drive, including file type
songLocation = '/content/drive/My Drive/'

## Song name
songName = ""

## Artist Name
artistName = ""

## Difficulty variable changes how many objects and the types of objects which spawn
## Easy = 1, Medium = 2, Hard = 3
dif =

#@title
y, sr = librosa.load(songLocation)

#@title
onsets = librosa.beat.onset.onset_detect(y, sr=sr, hop_length = 256, units = 'time')
liste =  [round(i * 30,0) for i in onsets]

#@title
## Extract features
mfcc = librosa.feature.mfcc(y, sr=sr, n_mfcc = 13)
mels = librosa.feature.melspectrogram(y=y, sr=sr, n_mels=2,hop_length = 256)
poly = librosa.feature.poly_features(y,sr=sr,hop_length=256)
tonn = librosa.feature.tonnetz(y,sr=sr)
rms = librosa.feature.rms(y,frame_length=2048,hop_length=256)
zero = librosa.feature.zero_crossing_rate(y, frame_length=2048, hop_length=256)

#@title
## Extract features that have a significant value worth affecting the gameplay
mfccFeat = []
melsFeat = []
polyFeat = []
tonnFeat = []
rmsFeat = []
zeroFeat = []

for i in range(mfcc.shape[1]):
  for j in range(mfcc.shape[0]):
    if(mfcc[j][i] > 130):
      mfccFeat.append(i)

for i in range(mels.shape[1]):
  for j in range(mels.shape[0]):
    if(mels[j][i] > 35):
      melsFeat.append(i)

for i in range(poly.shape[1]):
  for j in range(poly.shape[0]):
    if(poly[j][i] > 18):
      polyFeat.append(i)

for i in range(tonn.shape[1]):
  for j in range(tonn.shape[0]):
    if(tonn[j][i] > 0.3):
      tonnFeat.append(i)

for i in range(rms.shape[1]):
  for j in range(rms.shape[0]):
    if(rms[j][i] > 0.56):
      rmsFeat.append(i)

for i in range(zero.shape[1]):
  for j in range(zero.shape[0]):
    if(zero[j][i] < 0.02):
      zeroFeat.append(i)

#@title
## Pattern builder
## Use key extracted features to affect which objects spawn where

## Import random
import random

## List of which objects to spawn for each onset (in time order)
objectChoice = []

## Generate object list
## Loop through size of onsets, use liste for value at each point
for i in range(len(liste)):
  ## If statement affects how many objects spawn per round, for easy only 1/3, medium spawns 1/2 and for hard all onsets spawn something
  if((dif == 1 and i % 3 == 0) or (dif == 2 and i % 2 == 0) or (dif == 3)):
    ## If a MFCC feature is found near current onset, increase difficulty makes more likely
    if((liste[i] > mfccFeat[j] - (40 - (dif * 5))) and (liste[i] < mfccFeat[j] + (40 + (dif * 5)))):
      objectChoice.append(random.randint(1,2))
    ## If a Mel-Spectrogram feature is found near current onset, increase difficulty makes more likely
    elif((liste[i] > melsFeat[j] - (40 - (dif * 5))) and (liste[i] < melsFeat[j] + (40 + (dif * 5)))):
      objectChoice.append(random.randint(1,2))
    ## If Poly feature found near onset, increase difficulty makes more likely
    elif((liste[i] > polyFeat[j] - (40 - (dif * 5))) and (liste[i] < polyFeat[j] + (40 + (dif * 5)))):
      objectChoice.append(random.randint(3,4))
    ## If Tonnetz feature found near onset, increase difficulty makes more likely
    elif((liste[i] > tonnFeat[j] - (40 - (dif * 5))) and (liste[i] < tonnFeat[j] + (40 + (dif * 5)))):
      objectChoice.append(random.randint(3,4))
    ## If RMS feature found, spawn a golden ball, increase difficulty makes less likely
    elif((liste[i] > rmsFeat[j] - (20 + (dif * 5))) and (liste[i] < rmsFeat[j] + (20 - (dif * 5)))):
      objectChoice.append(5)
    ## If Zero-Crossing-Rate feature found spawn a bomb, increase difficulty makes significantly more likely
    elif((liste[i] > zeroFeat[j] - (30 - (dif * 10))) and (liste[i] < zeroFeat[j] + (30 + (dif * 10)))):
      objectChoice.append(6)
    ## If none of the features apply, spawn a regular ball
    else:
      objectChoice.append(7)

#@title
## Colour choice

## List to hold lane choices
laneChoice = []

## Loop through choices to pick lane
for i in range(len(objectChoice)):
  ## If spawning a left or right swipe only spawn in first two lanes
  if(objectChoice[i] == 1 or objectChoice[i] == 2):
    laneChoice.append(random.randint(0,1))
  ## If spawning a up or down swipe only spawn in last two lanes
  elif(objectChoice[i] == 3 or objectChoice[i] == 4):
    laneChoice.append(random.randint(1,2))
  ## All other objects can spawn in any lane  
  else:
    laneChoice.append(random.randint(0,2))

#@title
## Complete pattern
## Output to file

## File output
## Create file using songName
f = open("/content/drive/My Drive/" + songName + artistName + str(dif) + ".txt", "w")
a = 0
for i in range(len(liste)):
  if((dif == 1 and i % 3 == 0) or (dif == 2 and i % 2 == 0) or (dif == 3)):
    ## Add time, object type and colour to file
    f.write(str(liste[i]) + "&" + str(objectChoice[a]) + "&" + str(laneChoice[a]))
    a = a + 1
    ## Seperate each onset spawning information with new line
    if(a < len(objectChoice)):
        f.write("\n")
f.close()
print("Number of objects in round: " + str(a))
print("Saved to: " + songName + artistName + str(dif) + ".txt in drive")